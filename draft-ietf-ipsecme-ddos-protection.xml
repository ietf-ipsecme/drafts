<?xml version="1.0"?>
<?xml-stylesheet type='text/xsl' href='./rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc strict="yes" ?>
<?rfc linkmailto="yes" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" >

<?xml-stylesheet type='text/xsl' href='./rfc2629.xslt' ?>

<?rfc symrefs="yes"?>
<?rfc compact="yes" ?>
<?rfc subcompact="yes" ?>
<?rfc sortrefs="yes" ?>
<rfc ipr="trust200902" docName="draft-ietf-ipsecme-ddos-protection-01" category="std">
  <front>
    <title abbrev="DDoS Protection for IKE">Protecting Internet Key Exchange (IKE) Implementations from Distributed Denial of Service Attacks</title>
    <author initials="Y." surname="Nir" fullname="Yoav Nir">
      <organization abbrev="Check Point">Check Point Software Technologies Ltd.</organization>
      <address>
        <postal>
          <street>5 Hasolelim st.</street>
          <city>Tel Aviv</city>
          <code>6789735</code>
          <country>Israel</country>
        </postal>
        <email>ynir.ietf@gmail.com</email>
      </address>
    </author>
    <author initials="V." surname="Smyslov" fullname="Valery Smyslov">
      <organization abbrev="ELVIS-PLUS">ELVIS-PLUS</organization>
      <address>
        <postal>
          <street>PO Box 81</street>
          <city>Moscow (Zelenograd)</city>
          <code>124460</code>
          <country>Russian Federation</country>
        </postal>
        <phone>+7 495 276 0211</phone>
        <email>svan@elvis.ru</email>
      </address>
    </author>
    <date year="2015"/>
    <area>Security Area</area>
    <workgroup>IPSecME Working Group</workgroup>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t> This document recommends implementation and configuration best practices for Internet-connected IPsec Responders, to allow them to resist Denial of Service and Distributed Denial of Service attacks. Additionally, the document introduces a new mechanism called "Client Puzzles" that help accomplish this task.</t>
    </abstract>
  </front>
  <middle>
    <!-- ====================================================================== -->
    <section anchor="introduction" title="Introduction">
      <t> The IKE_SA_INIT Exchange described in section 1.2 of <xref target="RFC7296"/> involves the Initiator sending a single message. The Responder replies with a single message and also allocates memory for a structure called a half-open IKE SA (Security Association). This half-open SA is later authenticated in the IKE_AUTH Exchange, but if that IKE_AUTH request never comes, the half-open SA is kept for an unspecified amount of time. Depending on the algorithms used and implementation, such a half-open SA will use from around 100 bytes to several thousands bytes of memory.</t> 
      <t> This creates an easy attack vector against an Internet Key Exchange (IKE) Responder. Generating the Initial request is cheap, and sending multiple such requests can either cause the Responder to allocate too much resources and fail, or else if resource allocation is somehow throttled, legitimate Initiators would also be prevented from setting up IKE SAs.</t>
      <t> An obvious defense, which is described in <xref target="ratelimit"/>, is limiting the number of half-open SAs opened by a single peer. However, since all that is required is a single packet, an attacker can use multiple spoofed source IP addresses.</t>
      <t> Section 2.6 of RFC 7296 offers a mechanism to mitigate this DoS attack: the stateless cookie. When the server is under load, the Responder responds to the Initial request with a calculated "stateless cookie" - a value that can be re-calculated based on values in the Initial request without storing Responder-side state. The Initiator is expected to repeat the Initial request, this time including the stateless cookie.</t>
      <t> Attackers that have multiple source IP addresses with return routability, such as bot-nets can fill up a half-open SA table anyway. The cookie mechanism limits the amount of allocated state to the size of the bot-net, multiplied by the number of half-open SAs allowed for one peer address, multiplied by the amount of state allocated for each half-open SA. With typical values this can easily reach hundreds of megabytes.</t>
      <t> The mechanism described in <xref target="puzzles"/> adds a proof of work for the Initiator, by calculating a pre-image for a partial hash value. This sets an upper bound, determined by the attacker's CPU to the number of negotiations it can initiate in a unit of time.</t>
      <section anchor="mustshouldmay" title="Conventions Used in This Document">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
          "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described
          in <xref target="RFC2119"/>.</t>
      </section>
    </section>
    <section anchor="analysis" title="The Vulnerability">
      <t> If we break down what a responder has to do during an initial exchange, there are three stages:<list style="numbers">
        <t> When the Initial request arrives, the responder:<list style="symbols">
          <t> Generates or re-uses a D-H private part.</t>
          <t> Generates a responder SPI.</t>
          <t> Stores the private part and peer public part in a half-open SA database.</t></list></t>
        <t> When the Authentication request arrives, the responder:<list style="symbols">
          <t> Derives the keys from the half-open SA.</t>
          <t> Decrypts the request.</t></list></t>
        <t> If the Authentication request decrypts properly:<list style="symbols">
          <t> Validates the certificate chain (if present) in the auth request.</t></list></t></list></t>
      <t> Yes, there's a stage 4 where the responder actually creates Child SAs, but when talking about (D)DoS, we never get to this stage.</t>
      <t> Stage #1 is pretty light on CPU power, but requires some storage, and it's very light for the initiator as well. Stage #2 includes private-key operations, so it's much heavier CPU-wise, but it releases the storage allocated in stage #1. Stage #3 includes a public key operation, and possibly many of them.</t>
      <t> To attack such a server, an attacker can attempt to either exhaust memory or to exhaust CPU. Without any protection, the most efficient attack is to send multiple Initial requests and exhaust memory. This should be easy because those Initial requests are cheap.</t>
      <t> There are obvious ways for the responder to protect itself even without changes to the protocol. It can reduce the time that an entry remains in the half-open SA database, and it can limit the amount of concurrent half-open SAs from a particular address or prefix. The attacker can overcome this by using spoofed source addresses.</t>
      <t> The stateless cookie mechanism from section 2.6 of RFC 7296 prevents an attack with spoofed source addresses. This doesn't solve the issue, but it makes the limiting of half-open SAs by address or prefix work. Puzzles do the same thing only more of it. They make it harder for an attacker to reach the goal of getting a half-open SA. They don't have to be so hard that an attacker can't afford to solve them - it's enough that they increase the cost of a half-open SAs for the attacker.</t>
      <t> Reducing the amount of time an abandoned half-open SA is kept attacks the issue from the other side. It reduces the value the attacker gets from managing to create a half-open SA. So if a half-open SA takes 1 KB and it's kept for 1 minute and the capacity is 60,000 half-open SAs, an attacker would need to create 1,000 half-open SAs per second. Reduce the retention time to 3 seconds, and the attacker needs to create 20,000 half-open SAs per second. Make each of those more expensive by introducing a puzzle, and you're likely to thwart an exhaustion attack against responder memory.</t>
      <t> At this point, filling up the half-open SA database in no longer the most efficient DoS attack. The attacker has two ways to do better:<list style="numbers">
        <t> Go back to spoofed addresses and try to overwhelm the CPU that deals with generating cookies, or</t>
        <t> Take the attack to the next level by also sending an Authentication request.</t></list></t>
      <t> I don't think the first thing is something we can deal with at the IKE level. It's probably better left to Intrusion Prevention System (IPS) technology.</t>
      <t> Sending an Authentication request is surprisingly cheap. It requires a proper IKE header with the correct IKE SPIs, and it requires a single encrypted payload. The content of the payload might as well be junk. The responder has to perform the relatively expensive key derivation, only to find that the Authentication request does not decrypt. Depending on the responder implementation, this can be repeated with the same half-open SA (if the responder does not delete the half-open SA following an unsuccessful decryption - see discussion in <xref target="timelimit" />).</t>
      <t> Here too, the number of half-open SAs that the attacker can achieve is crucial, because each one of them allows the attacker to waste some CPU time. So making it hard to make many half-open SAs is important.</t>
      <t> A strategy against DDoS has to rely on at least 4 components:<list style="numbers">
        <t> Hardening the half-open SA database by reducing retention time.</t>
        <t> Hardening the half-open SA database by rate-limiting single IPs/prefixes.</t>
        <t> Guidance on what to do when an Authentication request fails to decrypt.</t>
        <t> Increasing cost of half-open SA up to what is tolerable for legitimate clients.</t></list></t>
      <t>Puzzles have their place as part of #4.</t>
    </section>
    <section anchor="puzzles" title="Puzzles">
      <t> The puzzle introduced here extends the cookie mechanism from RFC 7296. It is loosely based on the proof-of-work technique used in BitCoins (<xref target="bitcoins" />). Future versions of this document will have the exact bit structure of the notification payloads, but for now, I will only describe the semantics of the content.</t>
      <t> A puzzle is sent to the Initiator in two cases:<list style="symbols">
        <t> The Responder is so overloaded, than no half-open SAs are allowed to be created without the puzzle, or</t>
        <t> The Responder is not too loaded, but the rate-limiting in <xref target="ratelimit" /> prevents half-open SAs from being created with this particular peer address or prefix without first solving a puzzle.</t></list></t>
      <t> When the Responder decides to send the challenge notification in response to a IKE_SA_INIT request, the notification includes two fields:<list style="numbers">
        <t> Cookie - this is calculated the same as in RFC 7296. As in RFC 7296, the process of generating the cookie is not specified, but this specification does assume that it is fixed-length, meaning that all cookies produced by a particular responder are of the same length.</t>
        <t> Zero Bit Count. This is a number between 8 and 255 that represents the length of the zero-bit run at the end of the SHA-256 hash of the Cookie payload that the Initiator is to send. Since the mechanism is supposed to be stateless for the Responder, the same value is sent to all Initiators who are receiving this challenge. The values 0 and 1-8 are explicitly excluded, because the value zero is meaningless, and the values 1-8 create a puzzle that is too easy to solve to make any difference in mitigating DDoS attacks.</t></list></t>
      <t> Upon receiving this challenge payload, the Initiator attempts to append different strings to the Cookie field from the challenge, and calculates the SHA-256 hash of the result. When a string is found such that the resulting hash has a sufficient number of trailing zero bits, that result is sent to the Responder in a Cookie notification, similar to what is described in RFC 7296. The difference is that the string in this Cookie notification is longer than the one transmitted.</t>
      <t> When receiving a request with an extended Cookie, the Responder verifies two things:<list style="symbols">
        <t> That the first bits of the transmitted cookie are indeed valid.</t>
        <t> That the hash of the transmitted cookie has a sufficient number of trailing zero bits.</t></list></t>
      <t> Example 1: Suppose the calculated cookie is fdbcfa5a430d7201282358a2a034de0013cfe2ae (20 octets) and the required number of zero bits is 16. After successively trying a bunch of strings, the Initiator finds out that appending three octets: 022b3d yields a 23-octet string whose SHA-256 hash is 3b4bdf201105e059e09f65219021738b8f6a148896b2e1be2fdc726aeb6e0000. That has 17 trailing zero bits, so it is an acceptable cookie. </t>
      <t> Example 2: Same cookie, but this time the required number of zero bits is 22. The first string to satisfy that requirement is 5c2880, which yields a hash with 23 trailing zero bits. Finding this requires 6,105,472 hashes.</t>
      <texttable anchor="tbl1" title="COOKIE=fdbcfa5a430d7201282358a2a034de0013cfe2ae">
        <ttcol align="center">Appended String</ttcol>
        <ttcol align="left">Last 24 Hex Hash Digits</ttcol>
        <ttcol align="center"># 0-bits</ttcol>
        <ttcol align="center">Time To Calculate</ttcol>
<c>04</c><c>2817ae10f20f4e0b0739f5cc</c><c>2</c><c>0.000</c>
<c>06</c><c>e540cf315fff88c1c5f362a8</c><c>3</c><c>0.000</c>
<c>0d</c><c>8c459376268f747d7ed40da0</c><c>5</c><c>0.000</c>
<c>1c</c><c>398c49be1babe50576cdae40</c><c>6</c><c>0.000</c>
<c>00f0</c><c>3f523ad7c0e00252c51ad980</c><c>7</c><c>0.000</c>
<c>0182</c><c>e284296e2ffffa256bdfa800</c><c>11</c><c>0.000</c>
<c>235c</c><c>7dc74302dc8bd695821ab000</c><c>12</c><c>0.006</c>
<c>7186</c><c>a4411c3df3661eff1d574000</c><c>14</c><c>0.019</c>
<c>d836</c><c>498bcd04ab1ae0c2c3a08000</c><c>15</c><c>0.036</c>
<c>022b3d</c><c>96b2e1be2fdc726aeb6e0000</c><c>17</c><c>0.136</c>
<c>0aa679</c><c>620f48af85428996c1f00000</c><c>20</c><c>0.512</c>
<c>4ffbad</c><c>f9ba0ece854cd0fa88e00000</c><c>21</c><c>3.602</c>
<c>5c2880</c><c>d44e6467d8fc37723d800000</c><c>23</c><c>4.143</c>
<c>cdafe1</c><c>0d4058660c3e67be62000000</c><c>25</c><c>9.245</c>
<c>022bffc8</c><c>5f2d874764a71e2948000000</c><c>27</c><c>36.169</c>
<c>181ac92a</c><c>c3b5449fa1019b0580000000</c><c>31</c><c>255.076</c>
<c>a987978d</c><c>95a5673968a9b37a00000000</c><c>33</c><c>1309.519</c>
      </texttable>
      <t> The figures above were obtained on a 2.4 GHz single core i5. Run times can be halved or quartered with multi-core code, but would be longer on mobile phone processors, even if those are multi-core as well. With these figures I believe that 20 bits is a reasonable choice for puzzle level difficulty for all Initiators, with 24 bits acceptable for specific hosts/prefixes.</t>
    </section>
    <section anchor="timelimit" title="Retention Periods for Half-Open SAs">
      <t> As a UDP-based protocol, IKEv2 has to deal with packet loss through retransmissions. Section 2.4 of RFC 7296 recommends "that messages be retransmitted at least a dozen times over a period of at least several minutes before giving up". Retransmission policies in practice wait at least one or two seconds before retransmitting for the first time.</t>
      <t> Because of this, setting the timeout on a half-open SA too low will cause it to expire whenever even one IKE_AUTH request packet is lost. When not under attack, the half-open SA timeout SHOULD be set high enough that the Initiator will have enough time to send multiple retransmissions, minimizing the chance of transient network congestion causing IKE failure.</t>
      <t> When the system is under attack, as measured by the amount of half-open SAs, it makes sense to reduce this lifetime. The Responder should still allow enough time for the round-trip, enough time for the Initiator to derive the Diffie-Hellman shared value, and enough time to derive the IKE SA keys and the create the IKE_AUTH request. Two seconds is probably as low a value as can realistically be used.</t>
      <t> It could make sense to assign a shorter value to half-open SAs originating from IP addresses or prefixes from which are considered suspect because of multiple concurrent half-open SAs.</t>
    </section>
    <section anchor="ratelimit" title="Rate Limiting">
      <t> Even with DDoS, the attacker has only a limited amount of nodes participating in the attack. By limiting the amount of half-open SAs that are allowed to exist concurrently with each such node, the total amount of half-open SAs is capped, as is the total amount of key derivations that the Responder is forced to complete.</t>
      <t> In IPv4 it makes sense to limit the number of half-open SAs based on IP address. Most IPv4 nodes are either directly attached to the Internet using a routable address or are hidden behind a NAT device with a single IPv4 external address. IPv6 networks are currently a rarity, so we can only speculate on what their wide deployment will be like, but the current thinking is that ISP customers will be assigned whole subnets, so we don't expect the kind of NAT deployment that is common in IPv4. For this reason it makes sense to use a 64-bit prefix as the basis for rate limiting in IPv6.</t>
      <t> The number of half-open SAs is easy to measure, but it is also worthwhile to measure the number of failed IKE_AUTH exchanges. If possible, both factors should be taken into account when deciding which IP address or prefix is considered suspicious.</t>
      <t> There are two ways to rate-limit a peer address or prefix:<list style="numbers">
        <t> Hard Limit - where the number of half-open SAs is capped, and any further IKE_SA_INIT requests are rejected.</t>
        <t> Soft Limit - where if a set number of half-open SAs exist for a particular address or prefix, any IKE_SA_INIT request will require solving a puzzle.</t></list></t>
      <t> The advantage of the hard limit method is that it provides a hard cap on the amount of half-open SAs that the attacker is able to create. The downside is that it allows the attacker to block IKE initiation from small parts of the Internet. For example, if a certain purveyor of beverages resembling coffee provides Internet connectivity to its customers through an IPv4 NAT device, a single malicious customer can create enough half-open SAs to fill the quota for the NAT device external IP address. Legitimate Initiators on the same network will not be able to initiate IKE.</t>
      <t> The advantage of a soft limit is that legitimate clients can always connect. The disadvantage is that a sufficiently resourceful (in the sense that they have a lot of resources) adversary can still effectively DoS the Responder.</t>
      <t> Regardless of the type of rate-limiting used, there is a huge advantage in blocking the DoS attack using rate-limiting in that legitimate clients who are away from the attacking nodes should not be adversely affected by either the attack or by the measures used to counteract it.</t>
    </section>
    <section anchor="plan" title="Plan for Defending a Responder">
      <t> This section outlines a plan for defending a Responder from a DDoS attack based on the techniques described earlier. The numbers given here are not normative, and their purpose is to illustrate the configurable parameters needed for defeating the DDoS attack.</t>
      <t> Implementations may be deployed in different environments, so it is RECOMMENDED that the parameters be settable. As an example, most commercial products are required to undergo benchmarking where the IKE SA establishment rate is measured. Benchmarking is indistinguishable from a DoS attack and the defenses described in this document may defeat the benchmark by causing exchanges to fail or take a long time to complete. Parameters should be tunable to allow for benchmarking (if only by turning DDoS protection off).</t>
      <t> Since all countermeasures may cause delays and work on the initiators, they SHOULD NOT be deployed unless an attack is likely to be in progress. To minimize the burden imposed on Initiators, the Responder should monitor incoming IKE requests, searching for two things:<list style="numbers">
        <t> A general DDoS attack. Such an attack is indicated by a high number of concurrent half-open SAs, a high rate of failed IKE_AUTH exchanges, or a combination of both. For example, consider a Responder that has 10,000 distinct peers of which at peak 7,500 concurrently have VPN tunnels. At the start of peak time, 600 peers might establish tunnels at any given minute, and tunnel establishment (both IKE_SA_INIT and IKE_AUTH) takes anywhere from 0.5 to 2 seconds. For this Responder, we expect there to be less than 20 concurrent half-open SAs, so having 100 concurrent half-open SAs can be interpreted as an indication of an attack. Similarly, IKE_AUTH request decryption failures should never happen. Supposing the the tunnels are established using EAP (see section 2.16 or RFC 7296), users enter the wrong password about 20% of the time. So we'd expect 125 wrong password failures a minute. If we get IKE_AUTH decryption failures from multiple sources more than once per second, or EAP failure more than 300 times per minute, that can also be an indication of a DDoS attack.</t>
        <t> An attack from a particular IP address or prefix. Such an attack is indicated by an inordinate amount of half-open SAs from that IP address or prefix, or an inordinate amount of IKE_AUTH failures. A DDoS attack may be viewed as multiple such attacks. If they are mitigated well enough, there will not be a need enact countermeasures on all Initiators. Typical figures might be 5 concurrent half-open SAs, 1 decrypt failure, or 10 EAP failures within a minute.</t></list></t>
      <t> Note that using counter-measures against an attack from a particular IP address may be enough to avoid the load on the half-open SA database and the amount of failed IKE_AUTH exchanges to never exceed the threshold of attack detection. This is a good thing as it prevent Initiators that are not close to the attackers from being affected.</t>
      <t> When there is no general DDoS attack, it is suggested that no Cookie or puzzles be used. At this point the only defensive measure is the monitoring, and setting a soft limit per peer IP or prefix. The soft limit can be set to 3-5, and the puzzle difficulty should be set to such a level (number of zero-bits) that all legitimate clients can handle  it without degraded user experience.</t>
      <t> As soon as any kind of attack is detected, either a lot of initiations from multiple sources or a lot of initiations from a few sources, it is best to begin by requiring stateless cookies from all Initiators. This will force the attacker to use real source addresses, and help avoid the need to impose a greater burden in the form of cookies on the general population of initiators. This makes the per-node or per-prefix soft limit more effective.</t>
      <t> When Cookies are activated for all requests and the attacker is still managing to consume too many resources, the Responder MAY increase the difficulty of puzzles imposed on IKE_SA_INIT requests coming from suspicious nodes/prefixes. It should still be doable by all legitimate peers, but it can degrade experience, for example by taking up to 10 seconds to calculate the cookie extension.</t>
      <t> If the load on the Responder is still too great, and there are many nodes causing multiple half-open SAs or IKE_AUTH failures, the Responder MAY impose hard limits on those nodes.</t>
      <t> If it turns out that the attack is very widespread and the hard caps are not solving the issue, a puzzle MAY be imposed on all Initiators. Note that this is the last step, and the Responder should avoid this if possible.</t>
    </section>
    <section anchor="ops_cons" title="Operational Considerations">
      <t> [This section needs a lot of expanding]</t>
      <t> Not all Initiators support the puzzles, but all initiators are supposed to support stateless cookies. If this notification is sent to a non-supporting but legitimate initiator, the exchange will fail. Responders are advised to first try to mitigate the DoS using stateless cookies, even imposing them generally before resorting to using puzzles.</t>
      <t> The difficulty level should be set by balancing the requirement to minimize the latency for legitimate initiators and making things difficult for attackers. A good rule of thumb is for taking about 1 second to solve the puzzle. A typical initiator or bot-net member in 2014 can perform slightly less than a million hashes per second per core, so setting the difficulty level to n=20 is a good compromise. It should be noted that mobile initiators, especially phones are considerably weaker than that. Implementations should allow administrators to set the difficulty level, and/or be able to set the difficulty level dynamically in response to load.</t>
      <t> Initiators should set a maximum difficulty level beyond which they won't try to solve the puzzle and log or display a failure message to the administrator or user.</t>
    </section>

    <section title="Using Puzzles in the Protocol">
        <section anchor="negotiation" title="Puzzle Algorithm Negotiation">
            <t>Cryptographic algorithm agility is considered an important feature for modern protocols (<xref target="alg-agility" />). This feature ensures that protocol doesn't rely on a single build-in set of cryptographic algorithms, but has a means to replace one set with another and negotiate new set with the peer. IKEv2 fully supports cryptographic algorithm agility for its core operations.</t>
            <t>To support this feature in case of puzzles the algorithm, that is used to compute puzzle, needs to be negotiated during IKE_SA_INIT exchange. The negotiation is done as follows. The initial request message sent by Initiator contains SA payload with the list of transforms the Initiator supports and is willing to use in the IKE SA being established. If Responder continues with a puzzle, it must also inform the Initiator which algorithm to use to solve the puzzle. For this purpose the Responder parses received SA payload and finds mutually supported set of transforms of type PRF. It selects most preferred transform from this set and includes it into the PUZZLE notification that is sent back in the response message. There is no requirement that the PRF selected for puzzles be the same, as the PRF that is negotiated later for the use in core IKE SA crypto operations. If there are no mutually supported PRFs, then negotiation will fail anyway and there is no reason to return a puzzle. In this case the Responder returns NO_PROPOSAL_CHOSEN notification. Note that PRF is a mandatory transform type for IKE SA (see Sections 3.3.2 and 3.3.3 of <xref target="RFC7296" />) and at least one transform of this type must always be present in SA payload in IKE_SA_INIT exchange.</t>
        </section>

    </section>

    <section anchor="security" title="Security Considerations">
      <t> To be added.</t>
    </section>
    <section anchor="iana" title="IANA Considerations">  
      <t> IANA is requested to assign a notify message type from the status types range (16430-40959) of the "IKEv2 Notify Message Types - Status Types" registry with name "PUZZLE".</t>
    </section>
  </middle>
  <!-- ====================================================================== -->
  <back>
    <references title="Normative References"> 
      <reference anchor='RFC2119'>
        <front>
          <title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author initials='S.' surname='Bradner' fullname='Scott Bradner'>
            <organization>Harvard University</organization>
            <address>
              <postal>
                <street>1350 Mass. Ave.</street>
                <street>Cambridge</street>
                <street>MA 02138</street>
              </postal>
              <phone>- +1 617 495 3864</phone>
              <email>sob@harvard.edu</email>
            </address>
          </author>
          <date year='1997' month='March' />
          <area>General</area>
          <keyword>keyword</keyword>
        </front>
        <seriesInfo name='BCP' value='14' />
        <seriesInfo name='RFC' value='2119' />
        <format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
        <format type='HTML' octets='16553' target='http://tools.ietf.org/html/rfc2119' />
      </reference>
      <reference anchor="RFC7296">
        <front>
          <title>Internet Key Exchange Protocol Version 2 (IKEv2)</title>
          <author initials="T." surname="Kivinen" fullname="Tero Kivinen">
            <organization/>
          </author>
          <author initials="C." surname="Kaufman" fullname="C. Kaufman">
            <organization/>
          </author>
          <author initials="P." surname="Hoffman" fullname="P. Hoffman">
            <organization/>
          </author>
          <author initials="Y." surname="Nir" fullname="Y. Nir">
            <organization/>
          </author>
          <author initials="P." surname="Eronen" fullname="P. Eronen">
            <organization/>
          </author>
          <date year="2014" month="October"/>
        </front>
        <seriesInfo name="RFC" value="7296"/>
        <format type="TXT" target="http://www.rfc-editor.org/rfc/rfc7296.txt"/>
      </reference>
    </references>
    <references title="Informative References"> 
      <reference anchor='bitcoins' target="https://bitcoin.org/bitcoin.pdf">
        <front>
          <title>Bitcoin: A Peer-to-Peer Electronic Cash System</title>
          <author initials='S.' surname='Nakamoto' fullname='Satoshi Nakamoto'>
            <organization>bitcoin.org</organization>
            <address>
              <email>satoshin@gmx.com</email>
            </address>
          </author>
          <date year='2008' month='October' />
        </front>
        <format type='PDF' target="https://bitcoin.org/bitcoin.pdf" />
      </reference>
      <reference anchor='alg-agility'>
        <front>
          <title>Guidelines for Cryptographic Algorithm Agility</title>
          <author initials='R' surname='Housley' fullname='Russ Housley'>
            <organization />
          </author>
          <date month='December' day='29' year='2014' />
          <abstract><t>Many IETF protocols use cryptographic algorithms to provide confidentiality, integrity, or non-repudiation.  Communicating peers must support the same set of cryptographic algorithms for these mechanisms to work properly.  This memo provides guidelines to ensure that protocols have the ability to migrate from one algorithm suite to another over time.</t></abstract>
        </front>
        <seriesInfo name='Internet-Draft' value='draft-iab-crypto-alg-agility-02' />
        <format type='TXT' target='http://www.ietf.org/internet-drafts/draft-iab-crypto-alg-agility-02.txt' />
      </reference>
    </references>
    <!-- ====================================================================== -->
  </back>
</rfc>
